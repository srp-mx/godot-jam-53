using System;
using System.IO;
using System.Collections.Generic;
namespace Codegen;
public class ShaderFunctionFix
{
    private int gens = 1;
    private static readonly string prefix = "__gen_";
    private static readonly string fnCallSymbol = "¡¡";
    private static readonly string fnDefSymbol = "¿¿";
    private static readonly string fnRetSymbol = ">>>>";
    private static readonly string varLocalSymbol = "$";
    private static readonly string paramSymbol = "°";
    private static readonly string disclaimer =
@"/* 
THIS IS AUTOGENERATED CODE :D

==============================================================

Had some driver issues which appeared when compiling
function definitions on GLES 3 and my machine does not
even support Vulkan so...

If you're curious about the shader check the other similarly
named file with the .brokenshader suffix, if you're interested
about the code generation check out the srcgen directory. It's
a lazy implementation though because game jam but yeah..

Good luck!

==============================================================
*/

"; // This script isn't autogenerated though, lol

    // params will be called as
    //      
    // identifier -> body
    private Dictionary<string, string> fndefs = new();
    private Dictionary<string, string> fnrets = new();

    public void Do(string shaderPath)
    {
        foreach (string file in Directory.EnumerateFiles(shaderPath, "*.brokenshader.gdshader"))
        {
            Console.WriteLine($"Reading {Path.GetFileName(file)}...");
            string contents = File.ReadAllText(file);
            Console.WriteLine($"Parsing {Path.GetFileName(file)}...");
            string stripped = getFnDefs(contents);
            string newFileName = file.Replace(".brokenshader", "");

            Console.WriteLine($"Generating {Path.GetFileName(newFileName)}...");
            File.WriteAllText(newFileName, disclaimer + theFormatting(stripped));
        }
        Console.WriteLine($"Done ShaderFunctionFix at {shaderPath}.");
    }

    private string theFormatting(string src)
    {
        // find inline sites (calls)
        LinkedList<string> lines = new(src.Split('\n'));
        for (var n = lines.First; n.Next != null; n = n.Next)
        {
            if (n.Value.Contains(fnCallSymbol))
            {
                string[] callFrags = n.Value.Split(fnCallSymbol);
                bool isCall = false;
                for(int i = 0; i < callFrags.Length; i++)
                {
                    if (!isCall)
                    {
                        isCall = !isCall;
                        continue;
                    }

                    string iden;
                    List<string> paramtrs;
                    
                    stripCall(callFrags[i], out iden, out paramtrs);

                    lines.AddBefore(n, "\n"+fillBody(iden, paramtrs)+"\n");
                    callFrags[i] = replaceCall(callFrags[i], iden, paramtrs);
                    gens++; // each fn call has different number

                    isCall = !isCall;
                }

                string newline = "";
                foreach (string s in callFrags)
                {
                    newline += s;
                }
                n.Value = newline;
            }
        }

        string result = "";
        foreach(string line in lines)
        {
            result += line + "\n";   
        }
        return result;
    }

    // extracts identifier and parameters
    private void stripCall(string call, out string iden, out List<string>paramtrs)
    {
        paramtrs = new();
        int firstOpenParen = call.IndexOf('(');
        iden = call.Substring(0, firstOpenParen);
        string paramComma = call.Substring(firstOpenParen + 1);
        paramComma = paramComma.Substring(0, paramComma.LastIndexOf(')'));

        int lastOutComma = -1;
        int parendepth = 0;
        for (int i = 0; i < paramComma.Length; i++)
        {
            char cur = paramComma[i];
            if (cur == '(')
            {
                parendepth++;
                continue;
            }

            if (cur == ')')
            {
                parendepth--;
                continue;
            }

            if ((cur == ',' && parendepth == 0) || (i == paramComma.Length - 1))
            {
                paramtrs.Add(paramComma.Substring(lastOutComma + 1, i - lastOutComma));
                lastOutComma = i;
            }
        }
    }

    private string replaceLocalAndParam(string src, string id, List<string> paramInitVal)
    {
        string[] localsSplit = src.Split(varLocalSymbol);

        string localsPass = "";
        bool isLoc = false;
        foreach (string frag in localsSplit)
        {
            if (!isLoc)
            {
                isLoc = !isLoc;
                localsPass += frag;
                continue;
            }

            localsPass += $"{prefix}{id}{gens}_{frag}";

            isLoc = !isLoc;
        }

        string toParamSub = localsPass;
        while (toParamSub.Contains(paramSymbol))
        {
            int p = toParamSub.IndexOf(paramSymbol);
            string prepend = toParamSub.Substring(0, p);
            string apend = toParamSub.Substring(p+2);
            char paramnum = toParamSub[p+1];
            int paramint = int.Parse($"{paramnum}");
            toParamSub = prepend + paramInitVal[paramint] + apend;
        }

        return toParamSub;
    }

    // returns generated body
    private string fillBody(string iden, List<string> paramInitVal)
    {
        // must replace locals and param calls
        string bodyTemplate = fndefs.GetValueOrDefault(iden) ?? throw new Exception();
        return replaceLocalAndParam(bodyTemplate, iden, paramInitVal);
    }

    // returns return fragment instead of fn call
    // we have to replace locals and params here too
    private string replaceCall(string callLine, string iden, List<string> paramInitVal)
    {
        string retTemplate = fnrets.GetValueOrDefault(iden) ?? throw new Exception();
        return replaceLocalAndParam(retTemplate, iden, paramInitVal);
    }

    // Returns stripped
    private string getFnDefs(string src)
    {
        // expecting:
        // ¿¿fnName¿
        // ...
        // ¿¿
        string[] split = src.Split(fnDefSymbol);

        string returnable = "";
        bool isFn = false;
        foreach (string sub in split)
        {
            if (!isFn)
            {
                isFn = !isFn;
                // The function will get removed
                returnable += sub;
                continue;
            }

            string[] bodysplit = sub.Split(fnDefSymbol[0]);
            string identifier = bodysplit[0];
            string body = bodysplit[1];

            getFnRet(identifier, body);
            
            isFn = !isFn;
        }

        return returnable;
    }

    private void getFnRet(string iden, string body)
    {
        // expecting:
        // >>>> bla bla bla >>>>
        string[] split = body.Split(fnRetSymbol);
        bool isRet = false;

        string realbody = "";

        foreach(string sub in split)
        {
            if (!isRet)
            {
                isRet = !isRet;
                // Removes the return from the body since we'll add that inline
                realbody += sub;
                continue;
            }
            
            fnrets.Add(iden, sub);
            isRet = !isRet;
        }

        fndefs.Add(iden, realbody);
    }

}
